import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
from prophet import Prophet
import math
from datetime import timedelta
import google.generativeai as genai
import traceback
import os # <--- Import os module

# --- Google Gemini Configuration and Function ---

def configure_gemini():
    """Configures the Gemini API using the GOOGLE_API_KEY environment variable."""
    # --- Use os.getenv ---
    api_key = os.getenv("GOOGLE_API_KEY")
    # --- End Use os.getenv ---

    if not api_key: # Check if the key exists and is not empty
        st.error("ðŸ”´ Error: GOOGLE_API_KEY environment variable not found or empty. Please configure it in Posit Connect.")
        # Removed local .streamlit/secrets.toml mention as we now rely solely on env vars
        st.info("ðŸ’¡ For local testing, you might need to set this environment variable in your terminal.")
        return False
    try:
        genai.configure(api_key=api_key)
        # st.success("Gemini configured successfully.") # Optional: for debugging
        return True
    except Exception as e:
        st.error(f"ðŸ”´ An unexpected error occurred during Gemini configuration: {e}")
        return False

# --- get_gemini_analysis function remains the same internally, ---
# --- as it relies on configure_gemini() to handle the key ---
def get_gemini_analysis(forecast_df, last_actual_date, forecast_end_date, forecast_type, google_updates, last_actual_value):
    """
    Analyzes the Prophet forecast using Google Gemini API.
    (Code inside this function remains the same as before)
    """
    # Calls configure_gemini() which now uses os.getenv
    if not configure_gemini():
        return "Gemini API not configured. Analysis cannot proceed."

    try:
        # --- Prepare data for the prompt ---
        # (Keep the existing data preparation logic)
        future_forecast = forecast_df[
            (forecast_df['ds'] > last_actual_date) &
            (forecast_df['ds'] <= forecast_end_date)
        ].copy()

        if future_forecast.empty:
            return "No future forecast data available for the selected period to analyze."

        start_forecast_val = int(future_forecast.iloc[0]['yhat'])
        end_forecast_val = int(future_forecast.iloc[-1]['yhat'])
        avg_forecast_val = int(future_forecast['yhat'].mean())

        forecast_summary_str = f"""
        - Forecast Type: {forecast_type}
        - Forecast Start Date: {future_forecast.iloc[0]['ds'].strftime('%Y-%m-%d')}
        - Forecast End Date: {future_forecast.iloc[-1]['ds'].strftime('%Y-%m-%d')}
        - Last Actual Value ({last_actual_date.strftime('%Y-%m-%d')}): {int(last_actual_value)} {forecast_type.lower()} sessions
        - Forecasted Value at Start: {start_forecast_val} {forecast_type.lower()} sessions
        - Forecasted Value at End: {end_forecast_val} {forecast_type.lower()} sessions
        - Average Forecasted Value: {avg_forecast_val} {forecast_type.lower()} sessions
        - Overall Trend: {'Increasing' if end_forecast_val > start_forecast_val else 'Decreasing' if end_forecast_val < start_forecast_val else 'Stable'}
        - Confidence Range at End: ({int(future_forecast.iloc[-1]['yhat_lower'])}, {int(future_forecast.iloc[-1]['yhat_upper'])})
        """
        updates_str = "\n".join([f"- {label} ({pd.to_datetime(start).strftime('%Y-%m-%d')} to {pd.to_datetime(end).strftime('%Y-%m-%d')})" for start, end, label in google_updates])

        # --- Construct the prompt ---
        # (Keep the existing prompt)
        prompt = f"""
        Analyze the following SEO traffic (sessions) forecast generated by Prophet, keeping in mind the historical context of Google Algorithm Updates.

        Context:
        - The analysis is for a website's SEO traffic (measured in sessions).
        - The forecast uses the Prophet time series model.
        - Recent Google Algorithm Updates are provided for context, though the model may not explicitly account for them. Note any potential correlations or impacts if the forecast shows changes around update periods.

        Forecast Summary:
        {forecast_summary_str}

        Recent Google Algorithm Updates (YYYY-MM-DD):
        {updates_str}

        Task:
        Provide a concise analysis (around 3-5 bullet points or a short paragraph) summarizing the key findings from the forecast. Focus on:
        1. The overall predicted trend (growth, decline, stability).
        2. Expected traffic levels by the end of the forecast period.
        3. Any significant patterns or changes within the forecast period.
        4. Briefly mention if the forecast trend appears to be influenced by or heading into periods of known Google updates.
        5. Frame the analysis for an SEO Manager or stakeholder.
        """

        # --- Call the Gemini API ---
        model = genai.GenerativeModel('gemini-1.5-flash') # Or 'gemini-pro' or newer
        response = model.generate_content(prompt)
        analysis = response.text.replace('â€¢', '*') # Replace potential unicode bullets with markdown
        return analysis

    except genai.types.generation_types.BlockedPromptException:
         st.error("ðŸ”´ Gemini API Error: The prompt was blocked. This might be due to safety settings.")
         return "Analysis failed: Prompt was blocked by safety filters."
    except Exception as e:
        st.error(f"ðŸ”´ An error occurred while generating the AI analysis: {e}")
        st.error(f"Traceback: {traceback.format_exc()}") # Log detailed error
        return f"Analysis failed due to an error: {e}"


# --- load_data, plot_daily_forecast, plot_weekly_forecast, ---
# --- plot_monthly_forecast, display_dashboard remain the same ---
# (Make sure you have the corrected plot_daily_forecast from the previous step)
def load_data():
    uploaded_file = st.file_uploader("Choose a GA4 CSV file", type="csv")
    if uploaded_file is not None:
        try:
            df = pd.read_csv(uploaded_file)
            # Basic validation
            if 'Date' not in df.columns or 'Sessions' not in df.columns:
                st.error("ðŸ”´ Error: CSV must contain 'Date' and 'Sessions' columns.")
                return None
            else:
                 # Attempt date conversion early to catch format errors
                 try:
                     pd.to_datetime(df['Date'], format='%Y%m%d')
                     return df # Return df only if validation passes
                 except ValueError:
                     st.error("ðŸ”´ Error: 'Date' column must be in YYYYMMDD format.")
                     return None
        except Exception as e:
            st.error(f"ðŸ”´ Error loading or parsing CSV: {e}")
            return None
    else:
        #st.info("Awaiting CSV file upload...") # Commented out as it might be noisy before upload
        return None

# Corrected plot_daily_forecast (ensure this version is used)
def plot_daily_forecast(df, forecast_end_date):
    # Convert dates and rename columns for Prophet
    df['Date'] = pd.to_datetime(df['Date'], format='%Y%m%d')
    df.rename(columns={'Date': 'ds', 'Sessions': 'y'}, inplace=True)
    last_date = df['ds'].max()
    # Ensure last_actual_value is retrieved correctly, handle potential empty df edge case
    if df.empty:
         st.error("Input data is empty.")
         return None, None, None, []
    if last_date is pd.NaT:
         st.error("Could not determine the last date from the data.")
         return None, None, None, []

    # Get last actual value robustly
    last_row = df[df['ds'] == last_date]
    if last_row.empty:
        st.error(f"No data found for the last date {last_date}. Check data integrity.")
        return None, last_date, None, []
    last_actual_value = last_row['y'].iloc[0]


    # Compute forecast periods as the number of days from last observed date
    periods = (forecast_end_date - last_date).days
    if periods <= 0:
        st.error("Forecast end date must be after the last observed date for daily forecast.")
        # Return google_updates as empty list here as well
        google_updates = [] # Define google_updates even on error path if needed later
        return None, last_date, last_actual_value, google_updates # Return last actual value if available

    model = Prophet()
    model.fit(df)
    future = model.make_future_dataframe(periods=periods, freq='D')
    forecast = model.predict(future)

    # Plot actual vs. forecast
    fig, ax = plt.subplots(figsize=(16, 8))
    ax.plot(df['ds'], df['y'], label='Actual', color='blue')
    ax.plot(forecast['ds'], forecast['yhat'], label='Forecast', color='green')

    # Define Google updates list (ensure it's defined before the loop)
    google_updates = [
        ('20230315', '20230328', 'Mar 2023 Core Update'), ('20230822', '20230907', 'Aug 2023 Core Update'),
        ('20230914', '20230928', 'Sept 2023 Helpful Content Update'), ('20231004', '20231019', 'Oct 2023 Core & Spam Updates'),
        ('20231102', '20231204', 'Nov 2023 Core & Spam Updates'), ('20240305', '20240419', 'Mar 2024 Core Update'),
        ('20240506', '20240507', 'Site Rep Abuse'), ('20240514', '20240515', 'AI Overviews'),
        ('20240620', '20240627', 'June 2024 Core Update'), ('20240815', '20240903', 'Aug 2024 Core Update'),
        ('20241111', '20241205', 'Nov 2024 Core Update'), ('20241212', '20241218', 'Dec 2024 Core Update'),
        ('20241219', '20241226', 'Dec 2024 Spam Update'), ('20250313', '20250327', 'Mar 2025 Core Update')
    ]

    # Shade Google algorithm update ranges
    for start_str, end_str, label in google_updates:
        try:
            start_date = pd.to_datetime(start_str, format='%Y%m%d')
            end_date = pd.to_datetime(end_str, format='%Y%m%d')
            mid_date = start_date + (end_date - start_date) / 2 # Calculate mid_date inside the loop

            ax.axvspan(start_date, end_date, color='gray', alpha=0.2)
            y_limits = ax.get_ylim()
            if y_limits and len(y_limits) == 2 and y_limits[1] > y_limits[0]:
                 text_y_pos = y_limits[1] * 0.98
            else:
                 text_y_pos = forecast['yhat'].max() * 0.98 if not forecast.empty else 0

            ax.text(mid_date, text_y_pos, label, ha='center', va='top', fontsize=8, rotation=90)
        except Exception as e:
             st.warning(f"Could not plot Google update '{label}': {e}")

    ax.set_title('Daily Actual vs. Forecasted GA4 Sessions with Google Update Ranges')
    ax.set_xlabel('Date')
    ax.set_ylabel('Sessions')
    ax.legend()
    st.pyplot(fig)

    return forecast, last_date, last_actual_value, google_updates

# Ensure plot_weekly_forecast and plot_monthly_forecast are also correct
# (They should already return last_actual_value and google_updates, and have mid_date calculated correctly inside loop)
def plot_weekly_forecast(df, forecast_end_date):
    df['Date'] = pd.to_datetime(df['Date'], format='%Y%m%d')
    df.rename(columns={'Date': 'ds', 'Sessions': 'y'}, inplace=True)
    df_indexed = df.set_index('ds')
    df_weekly = df_indexed.resample('W').sum().reset_index()
    if df_weekly.empty:
         st.error("No weekly data after resampling.")
         return None, None, None, []
    last_date = df_weekly['ds'].max()
    if last_date is pd.NaT:
         st.error("Could not determine last weekly date.")
         return None, None, None, []
    last_actual_value = df_weekly[df_weekly['ds'] == last_date]['y'].iloc[0]

    periods = math.ceil((forecast_end_date - last_date).days / 7)
    if periods <= 0:
        st.error("Forecast end date must be after the last observed date for weekly forecast.")
        return None, last_date, last_actual_value, [] # Return empty updates

    model = Prophet()
    model.fit(df_weekly)
    future = model.make_future_dataframe(periods=periods, freq='W')
    forecast = model.predict(future)

    fig, ax = plt.subplots(figsize=(16, 8))
    ax.plot(df_weekly['ds'], df_weekly['y'], label='Weekly Actual', color='blue')
    ax.plot(forecast['ds'], forecast['yhat'], label='Weekly Forecast', color='green')

    google_updates = [ # Define or ensure updates are available here
        ('20230315', '20230328', 'Mar 2023 Core Update'), ('20230822', '20230907', 'Aug 2023 Core Update'),
        ('20230914', '20230928', 'Sept 2023 Helpful Content Update'), ('20231004', '20231019', 'Oct 2023 Core & Spam Updates'),
        ('20231102', '20231204', 'Nov 2023 Core & Spam Updates'), ('20240305', '20240419', 'Mar 2024 Core Update'),
        ('20240506', '20240507', 'Site Rep Abuse'), ('20240514', '20240515', 'AI Overviews'),
        ('20240620', '20240627', 'June 2024 Core Update'), ('20240815', '20240903', 'Aug 2024 Core Update'),
        ('20241111', '20241205', 'Nov 2024 Core Update'), ('20241212', '20241218', 'Dec 2024 Core Update'),
        ('20241219', '20241226', 'Dec 2024 Spam Update')
    ]
    for start_str, end_str, label in google_updates:
        try:
            start_date = pd.to_datetime(start_str, format='%Y%m%d')
            end_date = pd.to_datetime(end_str, format='%Y%m%d')
            mid_date = start_date + (end_date - start_date) / 2 # Correctly placed
            ax.axvspan(start_date, end_date, color='gray', alpha=0.2)
            y_limits = ax.get_ylim()
            if y_limits and len(y_limits) == 2 and y_limits[1] > y_limits[0]:
                 text_y_pos = y_limits[1] * 0.98
            else:
                 text_y_pos = forecast['yhat'].max() * 0.98 if not forecast.empty else 0
            ax.text(mid_date, text_y_pos, label, ha='center', va='top', fontsize=8, rotation=90)
        except Exception as e:
             st.warning(f"Could not plot Google update '{label}': {e}")

    ax.set_title('Weekly Actual vs. Forecasted GA4 Sessions with Google Update Ranges')
    ax.set_xlabel('Date')
    ax.set_ylabel('Sessions (Weekly)')
    ax.legend()
    st.pyplot(fig)

    return forecast, last_date, last_actual_value, google_updates

def plot_monthly_forecast(df, forecast_end_date):
    df['Date'] = pd.to_datetime(df['Date'], format='%Y%m%d')
    df.rename(columns={'Date': 'ds', 'Sessions': 'y'}, inplace=True)
    df_indexed = df.set_index('ds')
    df_monthly = df_indexed.resample('M').sum().reset_index() # 'M' is month end
    if df_monthly.empty:
         st.error("No monthly data after resampling.")
         return None, None, None, []
    last_date = df_monthly['ds'].max()
    if last_date is pd.NaT:
         st.error("Could not determine last monthly date.")
         return None, None, None, []
    last_actual_value = df_monthly[df_monthly['ds'] == last_date]['y'].iloc[0]

    periods = 0
    temp_date = last_date
    while temp_date < forecast_end_date:
        temp_date += pd.offsets.MonthEnd(1)
        periods += 1

    if periods <= 0 and forecast_end_date <= last_date:
        st.error("Forecast end date must be after the last observed month-end date for monthly forecast.")
        return None, last_date, last_actual_value, [] # Return empty updates

    model = Prophet()
    model.fit(df_monthly)
    future = model.make_future_dataframe(periods=periods, freq='M')
    forecast = model.predict(future)

    fig, ax = plt.subplots(figsize=(16, 8))
    ax.plot(df_monthly['ds'], df_monthly['y'], label='Monthly Actual', color='blue')
    ax.plot(forecast['ds'], forecast['yhat'], label='Monthly Forecast', color='green')

    google_updates = [ # Define or ensure updates are available here
        ('20230315', '20230328', 'Mar 2023 Core Update'), ('20230822', '20230907', 'Aug 2023 Core Update'),
        ('20230914', '20230928', 'Sept 2023 Helpful Content Update'), ('20231004', '20231019', 'Oct 2023 Core & Spam Updates'),
        ('20231102', '20231204', 'Nov 2023 Core & Spam Updates'), ('20240305', '20240419', 'Mar 2024 Core Update'),
        ('20240506', '20240507', 'Site Rep Abuse'), ('20240514', '20240515', 'AI Overviews'),
        ('20240620', '20240627', 'June 2024 Core Update'), ('20240815', '20240903', 'Aug 2024 Core Update'),
        ('20241111', '20241205', 'Nov 2024 Core Update'), ('20241212', '20241218', 'Dec 2024 Core Update'),
        ('20241219', '20241226', 'Dec 2024 Spam Update')
    ]
    for start_str, end_str, label in google_updates:
       try:
           start_date = pd.to_datetime(start_str, format='%Y%m%d')
           end_date = pd.to_datetime(end_str, format='%Y%m%d')
           mid_date = start_date + (end_date - start_date) / 2 # Correctly placed
           ax.axvspan(start_date, end_date, color='gray', alpha=0.2)
           y_limits = ax.get_ylim()
           if y_limits and len(y_limits) == 2 and y_limits[1] > y_limits[0]:
                text_y_pos = y_limits[1] * 0.98
           else:
                text_y_pos = forecast['yhat'].max() * 0.98 if not forecast.empty else 0
           ax.text(mid_date, text_y_pos, label, ha='center', va='top', fontsize=8, rotation=90)
       except Exception as e:
            st.warning(f"Could not plot Google update '{label}': {e}")

    ax.set_title('Monthly Actual vs. Forecasted GA4 Sessions with Google Update Ranges')
    ax.set_xlabel('Date')
    ax.set_ylabel('Sessions (Monthly)')
    ax.legend()
    st.pyplot(fig)

    return forecast, last_date, last_actual_value, google_updates

def display_dashboard(forecast, last_date, forecast_end_date, forecast_type):
    st.subheader("Forecast Data Table")
    forecast_filtered = forecast[(forecast['ds'] > last_date) & (forecast['ds'] <= forecast_end_date)]
    st.dataframe(forecast_filtered[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].round(0))

    horizon_str = ""
    if not forecast_filtered.empty:
        horizon = len(forecast_filtered)
        if forecast_type == "Daily Forecast": horizon_str = f"{horizon} days"
        elif forecast_type == "Weekly Forecast": horizon_str = f"{horizon} weeks"
        else: horizon_str = f"{horizon} months" # Monthly Forecast
    else:
        horizon_str = "N/A (No future forecast data)" # Handle empty case

    if forecast_filtered.empty:
        st.warning("No forecast data available within the selected future date range.")
        return

    forecast_value_at_end = forecast_filtered.iloc[-1]

    st.subheader("Forecast Summary")
    st.write(f"Last Actual Data Point: {last_date.date()}")
    st.write(f"Forecast End Date: {forecast_end_date.date()}")
    st.write(f"Forecast Horizon: {horizon_str}")

    forecast_range = int(forecast_value_at_end['yhat_upper'] - forecast_value_at_end['yhat_lower'])
    st.metric(label=f"Forecasted Traffic at {forecast_value_at_end['ds'].date()}",
              value=int(forecast_value_at_end['yhat']),
              delta=f"Â±{forecast_range / 2:.0f} (Range: {forecast_range})",
              delta_color="off")


# --- Main Application Logic ---
def main():
    st.set_page_config(page_title="Google Algorithm Impact Visualizer + AI Analysis", layout="wide")
    st.title("ðŸ“ˆ Google Algorithm Impact Visualizer with AI Analysis")
    st.write("""
        Upload your GA4 daily sessions CSV (columns: 'Date' as YYYYMMDD, 'Sessions').
        The app forecasts future traffic using Prophet, visualizes it against actuals, highlights Google updates,
        and optionally provides an AI-powered analysis of the forecast using Google Gemini.
    """)
    st.info("ðŸ’¡ Ensure your CSV has 'Date' (format YYYYMMDD) and 'Sessions' columns.")

    forecast_type = st.sidebar.radio("Select Forecast Type", ("Daily Forecast", "Weekly Forecast", "Monthly Forecast"))
    default_forecast_end = (pd.Timestamp.today() + timedelta(days=90)).date()
    forecast_end_date_input = st.sidebar.date_input("Select Forecast End Date", value=default_forecast_end, min_value=pd.Timestamp.today().date())
    forecast_end_date = pd.to_datetime(forecast_end_date_input)

    uploaded_file = st.file_uploader("Choose a GA4 CSV file", type="csv")
    df_original = None
    if uploaded_file is not None:
        df_original = load_data() # Use updated load_data which includes validation
        if df_original is not None:
             st.subheader("Data Preview (First 5 Rows)")
             st.dataframe(df_original.head())
    # else: # Removed the "Awaiting upload" message from here

    if df_original is not None:
        st.markdown("---")
        st.header("ðŸ“Š Forecast & Analysis")

        forecast = None
        last_date = None
        last_actual_value = None
        google_updates_used = []

        df_copy = df_original.copy()

        try:
            if forecast_type == "Daily Forecast":
                forecast, last_date, last_actual_value, google_updates_used = plot_daily_forecast(df_copy, forecast_end_date)
            elif forecast_type == "Weekly Forecast":
                forecast, last_date, last_actual_value, google_updates_used = plot_weekly_forecast(df_copy, forecast_end_date)
            else: # Monthly Forecast
                forecast, last_date, last_actual_value, google_updates_used = plot_monthly_forecast(df_copy, forecast_end_date)

            if forecast is not None and last_date is not None and last_actual_value is not None:
                st.markdown("---")
                display_dashboard(forecast, last_date, forecast_end_date, forecast_type)

                st.markdown("---")
                st.header("ðŸ¤– AI Forecast Analysis (Google Gemini)")

                # --- Modified Check using os.getenv ---
                api_key_present = bool(os.getenv("GOOGLE_API_KEY")) # Check if env var exists and is not empty
                # --- End Modified Check ---

                if not api_key_present:
                    st.warning("âš ï¸ GOOGLE_API_KEY environment variable not set. Please configure it in Posit Connect settings to enable AI analysis.")
                else:
                    if st.button("âœ¨ Generate AI Analysis"):
                        # Check configuration again right before calling, in case of transient issues
                        if configure_gemini():
                            with st.spinner("ðŸ§  Contacting Google Gemini for insights..."):
                                analysis_result = get_gemini_analysis(
                                    forecast_df=forecast,
                                    last_actual_date=last_date,
                                    forecast_end_date=forecast_end_date,
                                    forecast_type=forecast_type.split(" ")[0],
                                    google_updates=google_updates_used,
                                    last_actual_value=last_actual_value
                                )
                            st.markdown(analysis_result)
                        else:
                            # configure_gemini() already displayed an error
                            pass

        except Exception as e:
            st.error(f"ðŸ”´ An error occurred during forecasting or analysis: {e}")
            st.error(f"Traceback: {traceback.format_exc()}")


    st.markdown("---")
    st.markdown("Created by [The SEO Consultant.ai](https://theseoconsultant.ai/)")


if __name__ == "__main__":
    main()
