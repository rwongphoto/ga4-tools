import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
from prophet import Prophet
import math
from datetime import timedelta
import google.generativeai as genai # Import Gemini library
import traceback # For detailed error logging

# --- Google Gemini Configuration and Function ---

def configure_gemini():
    """Configures the Gemini API using the key from Streamlit secrets."""
    try:
        api_key = st.secrets["GOOGLE_API_KEY"]
        genai.configure(api_key=api_key)
        return True
    except KeyError:
        st.error("ðŸ”´ Error: GOOGLE_API_KEY not found in Streamlit secrets. Please configure it.")
        st.info("ðŸ’¡ For local development, add it to .streamlit/secrets.toml. For Posit Connect, add it as an environment variable/secret.")
        return False
    except Exception as e:
        st.error(f"ðŸ”´ An unexpected error occurred during Gemini configuration: {e}")
        return False

def get_gemini_analysis(forecast_df, last_actual_date, forecast_end_date, forecast_type, google_updates, last_actual_value):
    """
    Analyzes the Prophet forecast using Google Gemini API.

    Args:
        forecast_df (pd.DataFrame): The DataFrame containing the forecast results from Prophet.
        last_actual_date (pd.Timestamp): The last date with actual observed data.
        forecast_end_date (pd.Timestamp): The user-selected end date for the forecast.
        forecast_type (str): Type of forecast ('Daily', 'Weekly', 'Monthly').
        google_updates (list): List of tuples containing Google update info.
        last_actual_value (float): The last observed session value.

    Returns:
        str: The analysis summary from Gemini, or an error message.
    """
    if not configure_gemini():
        return "Gemini API not configured. Analysis cannot proceed."

    try:
        # --- Prepare data for the prompt ---
        # Filter forecast data for the relevant future period
        future_forecast = forecast_df[
            (forecast_df['ds'] > last_actual_date) &
            (forecast_df['ds'] <= forecast_end_date)
        ].copy()

        if future_forecast.empty:
            return "No future forecast data available for the selected period to analyze."

        # Simplify forecast data for the prompt (e.g., start, end, overall trend)
        start_forecast_val = int(future_forecast.iloc[0]['yhat'])
        end_forecast_val = int(future_forecast.iloc[-1]['yhat'])
        avg_forecast_val = int(future_forecast['yhat'].mean())

        forecast_summary_str = f"""
        - Forecast Type: {forecast_type}
        - Forecast Start Date: {future_forecast.iloc[0]['ds'].strftime('%Y-%m-%d')}
        - Forecast End Date: {future_forecast.iloc[-1]['ds'].strftime('%Y-%m-%d')}
        - Last Actual Value ({last_actual_date.strftime('%Y-%m-%d')}): {int(last_actual_value)} {forecast_type.lower()} sessions
        - Forecasted Value at Start: {start_forecast_val} {forecast_type.lower()} sessions
        - Forecasted Value at End: {end_forecast_val} {forecast_type.lower()} sessions
        - Average Forecasted Value: {avg_forecast_val} {forecast_type.lower()} sessions
        - Overall Trend: {'Increasing' if end_forecast_val > start_forecast_val else 'Decreasing' if end_forecast_val < start_forecast_val else 'Stable'}
        - Confidence Range at End: ({int(future_forecast.iloc[-1]['yhat_lower'])}, {int(future_forecast.iloc[-1]['yhat_upper'])})
        """

        # Format Google Updates for the prompt
        updates_str = "\n".join([f"- {label} ({pd.to_datetime(start).strftime('%Y-%m-%d')} to {pd.to_datetime(end).strftime('%Y-%m-%d')})" for start, end, label in google_updates])

        # --- Construct the prompt ---
        prompt = f"""
        Analyze the following SEO traffic (sessions) forecast generated by Prophet, keeping in mind the historical context of Google Algorithm Updates.

        Context:
        - The analysis is for a website's SEO traffic (measured in sessions).
        - The forecast uses the Prophet time series model.
        - Recent Google Algorithm Updates are provided for context, though the model may not explicitly account for them. Note any potential correlations or impacts if the forecast shows changes around update periods.

        Forecast Summary:
        {forecast_summary_str}

        Recent Google Algorithm Updates (YYYY-MM-DD):
        {updates_str}

        Task:
        Provide a concise analysis (around 3-5 bullet points or a short paragraph) summarizing the key findings from the forecast. Focus on:
        1. The overall predicted trend (growth, decline, stability).
        2. Expected traffic levels by the end of the forecast period.
        3. Any significant patterns or changes within the forecast period.
        4. Briefly mention if the forecast trend appears to be influenced by or heading into periods of known Google updates.
        5. Frame the analysis for an SEO Manager or stakeholder.
        """

        # --- Call the Gemini API ---
        model = genai.GenerativeModel('gemini-1.5-flash') # Or 'gemini-pro' or newer
        response = model.generate_content(prompt)

        # --- Return the analysis ---
        # Clean up potential markdown issues if needed
        analysis = response.text.replace('â€¢', '*') # Replace potential unicode bullets with markdown
        return analysis

    except genai.types.generation_types.BlockedPromptException:
         st.error("ðŸ”´ Gemini API Error: The prompt was blocked. This might be due to safety settings.")
         return "Analysis failed: Prompt was blocked by safety filters."
    except Exception as e:
        st.error(f"ðŸ”´ An error occurred while generating the AI analysis: {e}")
        st.error(f"Traceback: {traceback.format_exc()}") # Log detailed error
        return f"Analysis failed due to an error: {e}"

# --- Existing Functions (load_data, plot_daily_forecast, etc.) ---
# Keep your existing functions load_data, plot_daily_forecast, plot_weekly_forecast,
# plot_monthly_forecast, and display_dashboard as they are, with one minor addition:
# Make sure the plotting functions return the last *actual* value for use in Gemini prompt.

# --- Modified Plotting Functions (Example for plot_daily_forecast) ---
# Add returning last_actual_value

def plot_daily_forecast(df, forecast_end_date):
    # Convert dates and rename columns for Prophet
    df['Date'] = pd.to_datetime(df['Date'], format='%Y%m%d')
    df.rename(columns={'Date': 'ds', 'Sessions': 'y'}, inplace=True)
    last_date = df['ds'].max()
    last_actual_value = df[df['ds'] == last_date]['y'].iloc[0] # Get last actual value

    # Compute forecast periods as the number of days from last observed date
    periods = (forecast_end_date - last_date).days
    if periods <= 0:
        st.error("Forecast end date must be after the last observed date for daily forecast.")
        return None, last_date, None # Return None for last_actual_value on error

    model = Prophet()
    model.fit(df)
    future = model.make_future_dataframe(periods=periods, freq='D')
    forecast = model.predict(future)

    # Plot actual vs. forecast
    fig, ax = plt.subplots(figsize=(16, 8))
    ax.plot(df['ds'], df['y'], label='Actual', color='blue')
    ax.plot(forecast['ds'], forecast['yhat'], label='Forecast', color='green')

    # Shade Google algorithm update ranges
    google_updates = [
        ('20230315', '20230328', 'Mar 2023 Core Update'),
        ('20230822', '20230907', 'Aug 2023 Core Update'),
        ('20230914', '20230928', 'Sept 2023 Helpful Content Update'),
        ('20231004', '20231019', 'Oct 2023 Core & Spam Updates'),
        ('20231102', '20231204', 'Nov 2023 Core & Spam Updates'),
        ('20240305', '20240419', 'Mar 2024 Core Update'),
        ('20240506', '20240507', 'Site Rep Abuse'),
        ('20240514', '20240515', 'AI Overviews'),
        ('20240620', '20240627', 'June 2024 Core Update'),
        ('20240815', '20240903', 'Aug 2024 Core Update'),
        ('20241111', '20241205', 'Nov 2024 Core Update'),
        ('20241212', '20241218', 'Dec 2024 Core Update'),
        ('20241219', '20241226', 'Dec 2024 Spam Update'),
        ('20250313', '20250327', 'Mar 2025 Core Update')
    ]
    for start_str, end_str, label in google_updates:
        start_date = pd.to_datetime(start_str, format='%Y%m%d')
        end_date = pd.to_datetime(end_str, format='%Y%m%d')
        ax.axvspan(start_date, end_date, color='gray', alpha=0.2)
        # Adjusted text placement slightly lower to avoid overlapping title too much
        ax.text(mid_date, ax.get_ylim()[1] * 0.98, label, ha='center', va='top', fontsize=8, rotation=90) # Rotate text

    ax.set_title('Daily Actual vs. Forecasted GA4 Sessions with Google Update Ranges')
    ax.set_xlabel('Date')
    ax.set_ylabel('Sessions')
    ax.legend()
    st.pyplot(fig)

    # Return the full forecast, last date, and last actual value
    return forecast, last_date, last_actual_value, google_updates # Return updates too

# --- Similar modifications for plot_weekly_forecast and plot_monthly_forecast ---
# Make sure they also return `last_actual_value` and the `google_updates` list.
# Example for weekly (add return values):
def plot_weekly_forecast(df, forecast_end_date):
    # ... (previous code for processing and aggregation) ...
    df['Date'] = pd.to_datetime(df['Date'], format='%Y%m%d')
    df.rename(columns={'Date': 'ds', 'Sessions': 'y'}, inplace=True)
    df_indexed = df.set_index('ds') # Keep original df for last daily value access if needed? No, use aggregated.
    df_weekly = df_indexed.resample('W').sum().reset_index()
    last_date = df_weekly['ds'].max()
    last_actual_value = df_weekly[df_weekly['ds'] == last_date]['y'].iloc[0] # Get last weekly value

    # ... (rest of the code for periods calculation, Prophet fitting, prediction) ...
    periods = math.ceil((forecast_end_date - last_date).days / 7)
    if periods <= 0:
        st.error("Forecast end date must be after the last observed date for weekly forecast.")
        return None, last_date, None, [] # Return None/empty

    model = Prophet()
    model.fit(df_weekly)
    future = model.make_future_dataframe(periods=periods, freq='W')
    forecast = model.predict(future)

    # ... (plotting code, including google updates) ...
    google_updates = [ # Define or ensure updates are available here
        ('20230315', '20230328', 'Mar 2023 Core Update'),
        # ... other updates
        ('20241219', '20241226', 'Dec 2024 Spam Update')
    ]
    fig, ax = plt.subplots(figsize=(16, 8))
    ax.plot(df_weekly['ds'], df_weekly['y'], label='Weekly Actual', color='blue')
    ax.plot(forecast['ds'], forecast['yhat'], label='Weekly Forecast', color='green')
    for start_str, end_str, label in google_updates:
        start_date = pd.to_datetime(start_str, format='%Y%m%d')
        end_date = pd.to_datetime(end_str, format='%Y%m%d')
        ax.axvspan(start_date, end_date, color='gray', alpha=0.2)
        mid_date = start_date + (end_date - start_date) / 2
        ax.text(mid_date, ax.get_ylim()[1] * 0.98, label, ha='center', va='top', fontsize=8, rotation=90) # Rotate text

    ax.set_title('Weekly Actual vs. Forecasted GA4 Sessions with Google Update Ranges')
    ax.set_xlabel('Date')
    ax.set_ylabel('Sessions (Weekly)')
    ax.legend()
    st.pyplot(fig)

    return forecast, last_date, last_actual_value, google_updates

# Example for monthly (add return values):
def plot_monthly_forecast(df, forecast_end_date):
    # ... (previous code for processing and aggregation) ...
    df['Date'] = pd.to_datetime(df['Date'], format='%Y%m%d')
    df.rename(columns={'Date': 'ds', 'Sessions': 'y'}, inplace=True)
    df_indexed = df.set_index('ds')
    df_monthly = df_indexed.resample('M').sum().reset_index() # 'M' is month end, 'MS' is month start
    last_date = df_monthly['ds'].max()
    last_actual_value = df_monthly[df_monthly['ds'] == last_date]['y'].iloc[0] # Get last monthly value

    # ... (rest of the code for periods calculation, Prophet fitting, prediction) ...
    months_diff = (forecast_end_date.year - last_date.year) * 12 + (forecast_end_date.month - last_date.month)
    # Adjust periods based on 'M' (month end) frequency
    if forecast_end_date >= (last_date + pd.offsets.MonthEnd(0)): # If forecast end date is beyond the current month end
         periods = months_diff
    else: # If forecast ends within the same month as last actual
         periods = months_diff # Should be 0 if ends before month end, let Prophet handle short forecasts
    # A safer way for 'M' frequency: Calculate future dates until forecast_end_date
    periods = 0
    temp_date = last_date
    while temp_date < forecast_end_date:
        temp_date += pd.offsets.MonthEnd(1)
        periods += 1

    if periods <= 0 and forecast_end_date <= last_date:
        st.error("Forecast end date must be after the last observed month-end date for monthly forecast.")
        return None, last_date, None, [] # Return None/empty

    model = Prophet()
    model.fit(df_monthly)
    future = model.make_future_dataframe(periods=periods, freq='M') # Use 'M' for month end frequency
    forecast = model.predict(future)

    # ... (plotting code, including google updates) ...
    google_updates = [ # Define or ensure updates are available here
        ('20230315', '20230328', 'Mar 2023 Core Update'),
        # ... other updates
        ('20241219', '20241226', 'Dec 2024 Spam Update')
    ]
    fig, ax = plt.subplots(figsize=(16, 8))
    ax.plot(df_monthly['ds'], df_monthly['y'], label='Monthly Actual', color='blue')
    ax.plot(forecast['ds'], forecast['yhat'], label='Monthly Forecast', color='green')

    for start_str, end_str, label in google_updates:
        start_date = pd.to_datetime(start_str, format='%Y%m%d')
        end_date = pd.to_datetime(end_str, format='%Y%m%d')
        ax.axvspan(start_date, end_date, color='gray', alpha=0.2)
        mid_date = start_date + (end_date - start_date) / 2
        ax.text(mid_date, ax.get_ylim()[1] * 0.98, label, ha='center', va='top', fontsize=8, rotation=90) # Rotate text

    ax.set_title('Monthly Actual vs. Forecasted GA4 Sessions with Google Update Ranges')
    ax.set_xlabel('Date')
    ax.set_ylabel('Sessions (Monthly)')
    ax.legend()
    st.pyplot(fig)

    return forecast, last_date, last_actual_value, google_updates


# --- Main Application Logic ---
def main():
    st.set_page_config(page_title="Google Algorithm Impact Visualizer + AI Analysis", layout="wide")
    st.title("ðŸ“ˆ Google Algorithm Impact Visualizer with AI Analysis")
    st.write("""
        Upload your GA4 daily sessions CSV (columns: 'Date' as YYYYMMDD, 'Sessions').
        The app forecasts future traffic using Prophet, visualizes it against actuals, highlights Google updates,
        and optionally provides an AI-powered analysis of the forecast using Google Gemini.
    """)
    st.info("ðŸ’¡ Ensure your CSV has 'Date' (format YYYYMMDD) and 'Sessions' columns.")

    # Sidebar: choose forecast type and set forecast end date
    forecast_type = st.sidebar.radio("Select Forecast Type", ("Daily Forecast", "Weekly Forecast", "Monthly Forecast"))
    default_forecast_end = (pd.Timestamp.today() + timedelta(days=90)).date()
    forecast_end_date_input = st.sidebar.date_input("Select Forecast End Date", value=default_forecast_end, min_value=pd.Timestamp.today().date())
    forecast_end_date = pd.to_datetime(forecast_end_date_input)

    # Add file uploader here, before potential processing
    uploaded_file = st.file_uploader("Choose a GA4 CSV file", type="csv")

    df_original = None
    if uploaded_file is not None:
        try:
            df_original = pd.read_csv(uploaded_file)
            # Basic validation
            if 'Date' not in df_original.columns or 'Sessions' not in df_original.columns:
                st.error("ðŸ”´ Error: CSV must contain 'Date' and 'Sessions' columns.")
                df_original = None
            else:
                # Attempt date conversion early to catch format errors
                try:
                     pd.to_datetime(df_original['Date'], format='%Y%m%d')
                except ValueError:
                     st.error("ðŸ”´ Error: 'Date' column must be in YYYYMMDD format.")
                     df_original = None

                if df_original is not None:
                     st.subheader("Data Preview (First 5 Rows)")
                     st.dataframe(df_original.head())

        except Exception as e:
            st.error(f"ðŸ”´ Error loading or parsing CSV: {e}")
            df_original = None
    else:
        st.info("Awaiting CSV file upload...")

    # --- Forecasting and Analysis Section ---
    if df_original is not None:
        st.markdown("---")
        st.header("ðŸ“Š Forecast & Analysis")

        forecast = None
        last_date = None
        last_actual_value = None
        google_updates_used = [] # To store the list used in the plot

        # Ensure df_original is copied before passing to plotting functions
        df_copy = df_original.copy()

        try:
            if forecast_type == "Daily Forecast":
                forecast, last_date, last_actual_value, google_updates_used = plot_daily_forecast(df_copy, forecast_end_date)
            elif forecast_type == "Weekly Forecast":
                forecast, last_date, last_actual_value, google_updates_used = plot_weekly_forecast(df_copy, forecast_end_date)
            else: # Monthly Forecast
                forecast, last_date, last_actual_value, google_updates_used = plot_monthly_forecast(df_copy, forecast_end_date)

            if forecast is not None and last_date is not None and last_actual_value is not None:
                st.markdown("---")
                display_dashboard(forecast, last_date, forecast_end_date, forecast_type)

                # --- Gemini AI Analysis Section ---
                st.markdown("---")
                st.header("ðŸ¤– AI Forecast Analysis (Google Gemini)")

                # Check if API key is configured before showing the button
                api_key_configured = "GOOGLE_API_KEY" in st.secrets

                if not api_key_configured:
                    st.warning("âš ï¸ Google API Key not configured. Please set the `GOOGLE_API_KEY` secret/environment variable to enable AI analysis.")
                else:
                    if st.button("âœ¨ Generate AI Analysis"):
                        with st.spinner("ðŸ§  Contacting Google Gemini for insights..."):
                            analysis_result = get_gemini_analysis(
                                forecast_df=forecast,
                                last_actual_date=last_date,
                                forecast_end_date=forecast_end_date,
                                forecast_type=forecast_type.split(" ")[0], # Pass 'Daily', 'Weekly', 'Monthly'
                                google_updates=google_updates_used,
                                last_actual_value=last_actual_value
                            )
                        st.markdown(analysis_result) # Display raw markdown from Gemini

        except Exception as e:
            st.error(f"ðŸ”´ An error occurred during forecasting or plotting: {e}")
            st.error(f"Traceback: {traceback.format_exc()}")


    st.markdown("---")
    st.markdown("Created by [The SEO Consultant.ai](https://theseoconsultant.ai/)")

# --- Keep display_dashboard function as is ---
def display_dashboard(forecast, last_date, forecast_end_date, forecast_type):
    st.subheader("Forecast Data Table")
    # Show forecast rows between the last observed date and the selected forecast end date
    forecast_filtered = forecast[(forecast['ds'] > last_date) & (forecast['ds'] <= forecast_end_date)]
    st.dataframe(forecast_filtered[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].round(0)) # Round for cleaner display

    # Compute forecast horizon depending on forecast type
    horizon_str = ""
    if forecast_type == "Daily Forecast":
        horizon = (forecast_end_date - last_date).days
        horizon_str = f"{horizon} days"
    elif forecast_type == "Weekly Forecast":
        # Calculate weeks more accurately based on forecast dates if possible
        if not forecast_filtered.empty:
             horizon = len(forecast_filtered)
        else:
             horizon = math.ceil((forecast_end_date - last_date).days / 7) # Fallback
        horizon_str = f"{horizon} weeks"
    else:  # Monthly Forecast
        if not forecast_filtered.empty:
             horizon = len(forecast_filtered)
        else: # Fallback calculation
            months_diff = (forecast_end_date.year - last_date.year) * 12 + (forecast_end_date.month - last_date.month)
            # Rough adjustment based on day - better rely on forecast length
            # if forecast_end_date.day > last_date.day:
            #     months_diff += 1
            horizon = months_diff
        horizon_str = f"{horizon} months"

    # Find the forecast row closest to the forecast end date within the filtered future data
    if forecast_filtered.empty:
        st.warning("No forecast data available within the selected future date range.")
        return

    # Use the last row of the filtered forecast as it represents the end of the period
    forecast_value_at_end = forecast_filtered.iloc[-1]

    st.subheader("Forecast Summary")
    st.write(f"Last Actual Data Point: {last_date.date()}")
    st.write(f"Forecast End Date: {forecast_end_date.date()}")
    st.write(f"Forecast Horizon: {horizon_str}")

    # Calculate range as difference between upper and lower bounds at the end point
    forecast_range = int(forecast_value_at_end['yhat_upper'] - forecast_value_at_end['yhat_lower'])

    st.metric(label=f"Forecasted Traffic at {forecast_value_at_end['ds'].date()}",
              value=int(forecast_value_at_end['yhat']),
              delta=f"Â±{forecast_range / 2:.0f} (Range: {forecast_range})", # Show range centered around yhat
              delta_color="off") # Don't color delta based on value


if __name__ == "__main__":
    main()
