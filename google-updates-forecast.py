import streamlit as st
import pandas as pd
import os # Keep os import

# --- Other imports remain the same ---
import matplotlib.pyplot as plt
from prophet import Prophet
import math
from datetime import timedelta
import google.generativeai as genai
import traceback


# --- configure_gemini and get_gemini_analysis functions remain the same (using os.getenv) ---
def configure_gemini():
    """Configures the Gemini API using the GOOGLE_API_KEY environment variable."""
    api_key = os.getenv("GOOGLE_API_KEY")
    if not api_key:
        st.error("ðŸ”´ Error: GOOGLE_API_KEY environment variable not found or empty. Please configure it in Posit Connect.")
        st.info("ðŸ’¡ For local testing, you might need to set this environment variable in your terminal.")
        return False
    try:
        genai.configure(api_key=api_key)
        return True
    except Exception as e:
        st.error(f"ðŸ”´ An unexpected error occurred during Gemini configuration: {e}")
        return False

# get_gemini_analysis (no changes needed here)
def get_gemini_analysis(forecast_df, last_actual_date, forecast_end_date, forecast_type, google_updates, last_actual_value):
    if not configure_gemini():
        return "Gemini API not configured. Analysis cannot proceed."
    # (rest of the function is unchanged)
    try:
        # --- Prepare data for the prompt ---
        future_forecast = forecast_df[
            (forecast_df['ds'] > last_actual_date) &
            (forecast_df['ds'] <= forecast_end_date)
        ].copy()

        if future_forecast.empty:
            return "No future forecast data available for the selected period to analyze."

        start_forecast_val = int(future_forecast.iloc[0]['yhat'])
        end_forecast_val = int(future_forecast.iloc[-1]['yhat'])
        avg_forecast_val = int(future_forecast['yhat'].mean())

        forecast_summary_str = f"""
        - Forecast Type: {forecast_type}
        - Forecast Start Date: {future_forecast.iloc[0]['ds'].strftime('%Y-%m-%d')}
        - Forecast End Date: {future_forecast.iloc[-1]['ds'].strftime('%Y-%m-%d')}
        - Last Actual Value ({last_actual_date.strftime('%Y-%m-%d')}): {int(last_actual_value)} {forecast_type.lower()} sessions
        - Forecasted Value at Start: {start_forecast_val} {forecast_type.lower()} sessions
        - Forecasted Value at End: {end_forecast_val} {forecast_type.lower()} sessions
        - Average Forecasted Value: {avg_forecast_val} {forecast_type.lower()} sessions
        - Overall Trend: {'Increasing' if end_forecast_val > start_forecast_val else 'Decreasing' if end_forecast_val < start_forecast_val else 'Stable'}
        - Confidence Range at End: ({int(future_forecast.iloc[-1]['yhat_lower'])}, {int(future_forecast.iloc[-1]['yhat_upper'])})
        """
        updates_str = "\n".join([f"- {label} ({pd.to_datetime(start).strftime('%Y-%m-%d')} to {pd.to_datetime(end).strftime('%Y-%m-%d')})" for start, end, label in google_updates])

        # --- Construct the prompt ---
        prompt = f"""
        Analyze the following SEO traffic (sessions) forecast generated by Prophet, keeping in mind the historical context of Google Algorithm Updates.

        Context:
        - The analysis is for a website's SEO traffic (measured in sessions).
        - The forecast uses the Prophet time series model.
        - Recent Google Algorithm Updates are provided for context, though the model may not explicitly account for them. Note any potential correlations or impacts if the forecast shows changes around update periods.

        Forecast Summary:
        {forecast_summary_str}

        Recent Google Algorithm Updates (YYYY-MM-DD):
        {updates_str}

        Task:
        Provide a concise analysis (around 3-5 bullet points or a short paragraph) summarizing the key findings from the forecast. Focus on:
        1. The overall predicted trend (growth, decline, stability).
        2. Expected traffic levels by the end of the forecast period.
        3. Any significant patterns or changes within the forecast period.
        4. Briefly mention if the forecast trend appears to be influenced by or heading into periods of known Google updates.
        5. Frame the analysis for an SEO Manager or stakeholder.
        """

        # --- Call the Gemini API ---
        model = genai.GenerativeModel('gemini-1.5-flash')
        response = model.generate_content(prompt)
        analysis = response.text.replace('â€¢', '*')
        return analysis

    except genai.types.generation_types.BlockedPromptException:
         st.error("ðŸ”´ Gemini API Error: The prompt was blocked. This might be due to safety settings.")
         return "Analysis failed: Prompt was blocked by safety filters."
    except Exception as e:
        st.error(f"ðŸ”´ An error occurred while generating the AI analysis: {e}")
        st.error(f"Traceback: {traceback.format_exc()}")
        return f"Analysis failed due to an error: {e}"


# --- Updated load_data function ---
def load_data():
    # --- FIX: Add a unique key ---
    uploaded_file = st.file_uploader(
        "Choose a GA4 CSV file",
        type="csv",
        key="ga4_csv_uploader" # Assign a unique key here
    )
    # --- End Fix ---

    if uploaded_file is not None:
        try:
            df = pd.read_csv(uploaded_file)
            # Basic validation
            if 'Date' not in df.columns or 'Sessions' not in df.columns:
                st.error("ðŸ”´ Error: CSV must contain 'Date' and 'Sessions' columns.")
                return None
            else:
                 # Attempt date conversion early to catch format errors
                 try:
                     # Ensure 'Date' is treated as string for parsing if needed
                     df['Date'] = df['Date'].astype(str)
                     pd.to_datetime(df['Date'], format='%Y%m%d')
                     return df # Return df only if validation passes
                 except ValueError:
                     st.error("ðŸ”´ Error: 'Date' column contains values not in YYYYMMDD format.")
                     return None
                 except Exception as date_err: # Catch other potential errors during conversion
                     st.error(f"ðŸ”´ Error processing 'Date' column: {date_err}")
                     return None
        except Exception as e:
            st.error(f"ðŸ”´ Error loading or parsing CSV: {e}")
            return None
    else:
        # No file uploaded yet
        return None


# --- plot_daily_forecast, plot_weekly_forecast, plot_monthly_forecast, ---
# --- display_dashboard remain the same as the previous corrected versions ---
# (Ensure the plot functions have the mid_date fix and return correct values)
def plot_daily_forecast(df, forecast_end_date):
    # Convert dates and rename columns for Prophet
    df['Date'] = pd.to_datetime(df['Date'], format='%Y%m%d')
    df.rename(columns={'Date': 'ds', 'Sessions': 'y'}, inplace=True)
    last_date = df['ds'].max()
    if df.empty or last_date is pd.NaT:
         st.error("Input data is empty or last date cannot be determined.")
         return None, None, None, []
    last_row = df[df['ds'] == last_date]
    if last_row.empty:
        st.error(f"No data found for the last date {last_date}. Check data integrity.")
        return None, last_date, None, []
    last_actual_value = last_row['y'].iloc[0]

    periods = (forecast_end_date - last_date).days
    if periods <= 0:
        st.error("Forecast end date must be after the last observed date for daily forecast.")
        google_updates = []
        return None, last_date, last_actual_value, google_updates

    model = Prophet()
    model.fit(df)
    future = model.make_future_dataframe(periods=periods, freq='D')
    forecast = model.predict(future)

    fig, ax = plt.subplots(figsize=(16, 8))
    ax.plot(df['ds'], df['y'], label='Actual', color='blue')
    ax.plot(forecast['ds'], forecast['yhat'], label='Forecast', color='green')

    google_updates = [
        ('20230315', '20230328', 'Mar 2023 Core Update'), ('20230822', '20230907', 'Aug 2023 Core Update'),
        ('20230914', '20230928', 'Sept 2023 Helpful Content Update'), ('20231004', '20231019', 'Oct 2023 Core & Spam Updates'),
        ('20231102', '20231204', 'Nov 2023 Core & Spam Updates'), ('20240305', '20240419', 'Mar 2024 Core Update'),
        ('20240506', '20240507', 'Site Rep Abuse'), ('20240514', '20240515', 'AI Overviews'),
        ('20240620', '20240627', 'June 2024 Core Update'), ('20240815', '20240903', 'Aug 2024 Core Update'),
        ('20241111', '20241205', 'Nov 2024 Core Update'), ('20241212', '20241218', 'Dec 2024 Core Update'),
        ('20241219', '20241226', 'Dec 2024 Spam Update'), ('20250313', '20250327', 'Mar 2025 Core Update')
    ]

    for start_str, end_str, label in google_updates:
        try:
            start_date = pd.to_datetime(start_str, format='%Y%m%d')
            end_date = pd.to_datetime(end_str, format='%Y%m%d')
            mid_date = start_date + (end_date - start_date) / 2 # Calculate mid_date inside the loop
            ax.axvspan(start_date, end_date, color='gray', alpha=0.2)
            y_limits = ax.get_ylim()
            text_y_pos = y_limits[1] * 0.98 if y_limits and len(y_limits) == 2 and y_limits[1] > y_limits[0] else (forecast['yhat'].max() * 0.98 if not forecast.empty else 0)
            ax.text(mid_date, text_y_pos, label, ha='center', va='top', fontsize=8, rotation=90)
        except Exception as e:
             st.warning(f"Could not plot Google update '{label}': {e}")

    ax.set_title('Daily Actual vs. Forecasted GA4 Sessions with Google Update Ranges')
    ax.set_xlabel('Date')
    ax.set_ylabel('Sessions')
    ax.legend()
    st.pyplot(fig)
    plt.close(fig) # Close the figure to release memory

    return forecast, last_date, last_actual_value, google_updates

def plot_weekly_forecast(df, forecast_end_date):
    df['Date'] = pd.to_datetime(df['Date'], format='%Y%m%d')
    df.rename(columns={'Date': 'ds', 'Sessions': 'y'}, inplace=True)
    df_indexed = df.set_index('ds')
    df_weekly = df_indexed.resample('W').sum().reset_index()
    if df_weekly.empty or df_weekly['ds'].max() is pd.NaT:
         st.error("No weekly data or last date invalid after resampling.")
         return None, None, None, []
    last_date = df_weekly['ds'].max()
    last_actual_value = df_weekly[df_weekly['ds'] == last_date]['y'].iloc[0]

    periods = math.ceil((forecast_end_date - last_date).days / 7)
    if periods <= 0:
        st.error("Forecast end date must be after the last observed date for weekly forecast.")
        return None, last_date, last_actual_value, []

    model = Prophet()
    model.fit(df_weekly)
    future = model.make_future_dataframe(periods=periods, freq='W')
    forecast = model.predict(future)

    fig, ax = plt.subplots(figsize=(16, 8))
    ax.plot(df_weekly['ds'], df_weekly['y'], label='Weekly Actual', color='blue')
    ax.plot(forecast['ds'], forecast['yhat'], label='Weekly Forecast', color='green')

    google_updates = [
        ('20230315', '20230328', 'Mar 2023 Core Update'), ('20230822', '20230907', 'Aug 2023 Core Update'),
        ('20230914', '20230928', 'Sept 2023 Helpful Content Update'), ('20231004', '20231019', 'Oct 2023 Core & Spam Updates'),
        ('20231102', '20231204', 'Nov 2023 Core & Spam Updates'), ('20240305', '20240419', 'Mar 2024 Core Update'),
        ('20240506', '20240507', 'Site Rep Abuse'), ('20240514', '20240515', 'AI Overviews'),
        ('20240620', '20240627', 'June 2024 Core Update'), ('20240815', '20240903', 'Aug 2024 Core Update'),
        ('20241111', '20241205', 'Nov 2024 Core Update'), ('20241212', '20241218', 'Dec 2024 Core Update'),
        ('20241219', '20241226', 'Dec 2024 Spam Update')
    ]
    for start_str, end_str, label in google_updates:
        try:
            start_date = pd.to_datetime(start_str, format='%Y%m%d')
            end_date = pd.to_datetime(end_str, format='%Y%m%d')
            mid_date = start_date + (end_date - start_date) / 2
            ax.axvspan(start_date, end_date, color='gray', alpha=0.2)
            y_limits = ax.get_ylim()
            text_y_pos = y_limits[1] * 0.98 if y_limits and len(y_limits) == 2 and y_limits[1] > y_limits[0] else (forecast['yhat'].max() * 0.98 if not forecast.empty else 0)
            ax.text(mid_date, text_y_pos, label, ha='center', va='top', fontsize=8, rotation=90)
        except Exception as e:
             st.warning(f"Could not plot Google update '{label}': {e}")

    ax.set_title('Weekly Actual vs. Forecasted GA4 Sessions with Google Update Ranges')
    ax.set_xlabel('Date')
    ax.set_ylabel('Sessions (Weekly)')
    ax.legend()
    st.pyplot(fig)
    plt.close(fig) # Close the figure

    return forecast, last_date, last_actual_value, google_updates

def plot_monthly_forecast(df, forecast_end_date):
    df['Date'] = pd.to_datetime(df['Date'], format='%Y%m%d')
    df.rename(columns={'Date': 'ds', 'Sessions': 'y'}, inplace=True)
    df_indexed = df.set_index('ds')
    df_monthly = df_indexed.resample('M').sum().reset_index()
    if df_monthly.empty or df_monthly['ds'].max() is pd.NaT:
         st.error("No monthly data or last date invalid after resampling.")
         return None, None, None, []
    last_date = df_monthly['ds'].max()
    last_actual_value = df_monthly[df_monthly['ds'] == last_date]['y'].iloc[0]

    periods = 0
    temp_date = last_date
    while temp_date < forecast_end_date:
        temp_date += pd.offsets.MonthEnd(1)
        periods += 1

    if periods <= 0 and forecast_end_date <= last_date:
        st.error("Forecast end date must be after the last observed month-end date for monthly forecast.")
        return None, last_date, last_actual_value, []

    model = Prophet()
    model.fit(df_monthly)
    future = model.make_future_dataframe(periods=periods, freq='M')
    forecast = model.predict(future)

    fig, ax = plt.subplots(figsize=(16, 8))
    ax.plot(df_monthly['ds'], df_monthly['y'], label='Monthly Actual', color='blue')
    ax.plot(forecast['ds'], forecast['yhat'], label='Monthly Forecast', color='green')

    google_updates = [
        ('20230315', '20230328', 'Mar 2023 Core Update'), ('20230822', '20230907', 'Aug 2023 Core Update'),
        ('20230914', '20230928', 'Sept 2023 Helpful Content Update'), ('20231004', '20231019', 'Oct 2023 Core & Spam Updates'),
        ('20231102', '20231204', 'Nov 2023 Core & Spam Updates'), ('20240305', '20240419', 'Mar 2024 Core Update'),
        ('20240506', '20240507', 'Site Rep Abuse'), ('20240514', '20240515', 'AI Overviews'),
        ('20240620', '20240627', 'June 2024 Core Update'), ('20240815', '20240903', 'Aug 2024 Core Update'),
        ('20241111', '20241205', 'Nov 2024 Core Update'), ('20241212', '20241218', 'Dec 2024 Core Update'),
        ('20241219', '20241226', 'Dec 2024 Spam Update')
    ]
    for start_str, end_str, label in google_updates:
       try:
           start_date = pd.to_datetime(start_str, format='%Y%m%d')
           end_date = pd.to_datetime(end_str, format='%Y%m%d')
           mid_date = start_date + (end_date - start_date) / 2
           ax.axvspan(start_date, end_date, color='gray', alpha=0.2)
           y_limits = ax.get_ylim()
           text_y_pos = y_limits[1] * 0.98 if y_limits and len(y_limits) == 2 and y_limits[1] > y_limits[0] else (forecast['yhat'].max() * 0.98 if not forecast.empty else 0)
           ax.text(mid_date, text_y_pos, label, ha='center', va='top', fontsize=8, rotation=90)
       except Exception as e:
            st.warning(f"Could not plot Google update '{label}': {e}")

    ax.set_title('Monthly Actual vs. Forecasted GA4 Sessions with Google Update Ranges')
    ax.set_xlabel('Date')
    ax.set_ylabel('Sessions (Monthly)')
    ax.legend()
    st.pyplot(fig)
    plt.close(fig) # Close the figure

    return forecast, last_date, last_actual_value, google_updates

def display_dashboard(forecast, last_date, forecast_end_date, forecast_type):
    st.subheader("Forecast Data Table")
    forecast_filtered = forecast[(forecast['ds'] > last_date) & (forecast['ds'] <= forecast_end_date)]
    # Display rounded dataframe, handle empty case
    if not forecast_filtered.empty:
        st.dataframe(forecast_filtered[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].astype({'yhat':'int', 'yhat_lower':'int', 'yhat_upper':'int'})) # Cast to int for cleaner look
    else:
        st.write("No forecast data in the selected future range.")


    horizon_str = ""
    if not forecast_filtered.empty:
        horizon = len(forecast_filtered)
        if forecast_type == "Daily Forecast": horizon_str = f"{horizon} days"
        elif forecast_type == "Weekly Forecast": horizon_str = f"{horizon} weeks"
        else: horizon_str = f"{horizon} months" # Monthly Forecast
    else:
        horizon_str = "N/A (No future forecast data)"

    st.subheader("Forecast Summary")
    st.write(f"Last Actual Data Point: {last_date.date()}")
    st.write(f"Forecast End Date: {forecast_end_date.date()}")
    st.write(f"Forecast Horizon: {horizon_str}")

    if forecast_filtered.empty:
        # st.warning("No forecast data available within the selected future date range for summary.") # Redundant if table shows message
        return

    forecast_value_at_end = forecast_filtered.iloc[-1]
    forecast_range = int(forecast_value_at_end['yhat_upper'] - forecast_value_at_end['yhat_lower'])
    delta_val = forecast_range / 2
    st.metric(label=f"Forecasted Traffic at {forecast_value_at_end['ds'].date()}",
              value=int(forecast_value_at_end['yhat']),
              delta=f"Â±{delta_val:.0f} (Range: {forecast_range})",
              delta_color="off")


# --- Main function remains largely the same ---
def main():
    st.set_page_config(page_title="Google Algorithm Impact Visualizer + AI Analysis", layout="wide")
    st.title("ðŸ“ˆ Google Algorithm Impact Visualizer with AI Analysis")
    st.write("""
        Upload your GA4 daily sessions CSV (columns: 'Date' as YYYYMMDD, 'Sessions').
        The app forecasts future traffic using Prophet, visualizes it against actuals, highlights Google updates,
        and optionally provides an AI-powered analysis of the forecast using Google Gemini.
    """)
    st.info("ðŸ’¡ Ensure your CSV has 'Date' (format YYYYMMDD) and 'Sessions' columns.")

    forecast_type = st.sidebar.radio("Select Forecast Type", ("Daily Forecast", "Weekly Forecast", "Monthly Forecast"), key="forecast_type_radio") # Added key
    default_forecast_end = (pd.Timestamp.today() + timedelta(days=90)).date()
    forecast_end_date_input = st.sidebar.date_input("Select Forecast End Date", value=default_forecast_end, min_value=pd.Timestamp.today().date(), key="forecast_date_input") # Added key
    forecast_end_date = pd.to_datetime(forecast_end_date_input)

    # Call load_data which now has the key in the file_uploader
    df_original = load_data()

    if df_original is not None:
        st.subheader("Data Preview (First 5 Rows)")
        st.dataframe(df_original.head())

        st.markdown("---")
        st.header("ðŸ“Š Forecast & Analysis")

        forecast = None
        last_date = None
        last_actual_value = None
        google_updates_used = []

        df_copy = df_original.copy() # Copy df before passing to plotting functions

        try:
            plot_function = None
            if forecast_type == "Daily Forecast":
                 plot_function = plot_daily_forecast
            elif forecast_type == "Weekly Forecast":
                 plot_function = plot_weekly_forecast
            else: # Monthly Forecast
                 plot_function = plot_monthly_forecast

            # Use a spinner for the potentially long forecasting/plotting step
            with st.spinner(f"Generating {forecast_type.lower()} forecast and plot..."):
                forecast, last_date, last_actual_value, google_updates_used = plot_function(df_copy, forecast_end_date)

            if forecast is not None and last_date is not None and last_actual_value is not None:
                st.markdown("---")
                display_dashboard(forecast, last_date, forecast_end_date, forecast_type)

                st.markdown("---")
                st.header("ðŸ¤– AI Forecast Analysis (Google Gemini)")

                api_key_present = bool(os.getenv("GOOGLE_API_KEY"))

                if not api_key_present:
                    st.warning("âš ï¸ GOOGLE_API_KEY environment variable not set. Please configure it in Posit Connect settings to enable AI analysis.")
                else:
                    # Use a unique key for the button as well
                    if st.button("âœ¨ Generate AI Analysis", key="generate_ai_button"):
                        if configure_gemini(): # Check config right before call
                            with st.spinner("ðŸ§  Contacting Google Gemini for insights..."):
                                analysis_result = get_gemini_analysis(
                                    forecast_df=forecast,
                                    last_actual_date=last_date,
                                    forecast_end_date=forecast_end_date,
                                    forecast_type=forecast_type.split(" ")[0],
                                    google_updates=google_updates_used,
                                    last_actual_value=last_actual_value
                                )
                            st.markdown(analysis_result)
                        # else: configure_gemini already showed error

        except Exception as e:
            st.error(f"ðŸ”´ An error occurred during forecasting or analysis: {e}")
            st.error(f"Traceback: {traceback.format_exc()}")

    else:
        # Display info message only if no file has been uploaded yet
        # Check if 'ga4_csv_uploader' state exists and is None/empty
        if 'ga4_csv_uploader' not in st.session_state or st.session_state.ga4_csv_uploader is None:
              st.info("Awaiting CSV file upload...")


    st.markdown("---")
    st.markdown("Created by [The SEO Consultant.ai](https://theseoconsultant.ai/)")


if __name__ == "__main__":
    main()
